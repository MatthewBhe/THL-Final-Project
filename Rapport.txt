Exo 1) 

J'ai utilisé Flex pour lire les expressions ensemblistes. Quand le mot "card" est rencontré, on passe en mode spécial pour compter les éléments d'un ensemble. Pour cela, j'ai créé une fonction externe, countElements, qui fait le comptage sans utiliser de boucles ou de conditions directement dans Flex. Le problème principal a été de bien remettre le mode "card" à zéro après le comptage, afin que ça ne perturbe pas la lecture des autres ensembles. J'ai aussi eu des avertissements sur la fonction input() générée par Flex, que j'ai choisi d'ignorer en ajoutant une option de compilation.


Exo 2) 
Dans cet exercice, nous avons opté pour une représentation des ensembles sous forme de bitmask sur 64 bits afin de simplifier la gestion des opérations ensemblistes (union, intersection, différence et complément) tout en éliminant automatiquement les doublons. Ce choix technique permet d'exploiter efficacement les opérations logiques pour combiner et manipuler les ensembles. Par ailleurs, une attention particulière a été portée à la gestion des erreurs, avec des messages explicites déclenchés dès qu'une anomalie lexicale ou syntaxique est détectée. Parmi les difficultés rencontrées, la définition d'une grammaire suffisamment précise pour éviter les ambiguïtés, notamment en ce qui concerne la manipulation des identifiants utilisés comme indices dans la table des symboles, a nécessité plusieurs ajustements afin d'assurer une interprétation fiable des expressions.

3)
Dans cet exercice, nous avons choisi de représenter les ensembles par un entier non signé de 64 bits, ce qui permet de réaliser efficacement les opérations ensemblistes à l'aide d'opérateurs bit-à-bit. Ce choix facilite notamment l'union, l'intersection, et la différence entre ensembles, tout en éliminant automatiquement les doublons. Par ailleurs, la gestion d'une table de symboles pour les identifiants permet de traiter les affectations et les copies d'ensembles de manière claire et directe. Parmi les principales difficultés rencontrées, la conception d'une grammaire non ambiguë a nécessité de repenser l'ordre de priorité des opérateurs, notamment pour différencier l'opérateur binaire de complément (ou différence) et d'autres opérations. La gestion fine des erreurs lexicales et syntaxiques afin d'assurer une interprétation robuste des expressions a également été un challenge majeur. Ces choix techniques et les ajustements effectués ont permis de développer un interpréteur sémantique performant et fiable, capable d'exécuter des expressions ensemblistes complexes avec précision.

4)
Dans cette étape, nous avons intégré une gestion fine des erreurs et établi des priorités claires entre les opérateurs. Pour garantir que des expressions telles que « A := card(A) » déclenchent un message d'erreur explicite, nous avons défini une production spécifique pour l'affectation d'expressions numériques, empêchant ainsi l'attribution d'une valeur numérique à une variable d'ensemble. Nous avons également structuré la grammaire en plusieurs niveaux (union, intersection/minus, complément) pour assurer une interprétation correcte des priorités, en particulier dans les expressions complexes avec parenthèses. Parmi les difficultés rencontrées, il a fallu trouver un compromis entre flexibilité et robustesse : la décomposition de la grammaire en sous-niveaux a nécessité plusieurs ajustements pour éviter des conflits de réduction tout en préservant une interprétation naturelle des expressions. Ce travail a permis d'obtenir un analyseur sémantique cohérent, capable de gérer à la fois la syntaxe et les erreurs d'affectation, conformément aux exigences du projet.
